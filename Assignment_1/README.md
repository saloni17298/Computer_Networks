# Assignment 1 - Socket Programming

## Authors
1. Akshat Maheshwari - 20161024
2. Sayak Kundu - 20161035

## State diagram for server and client model

![State Diagram](http://cdncontribute.geeksforgeeks.org/wp-content/uploads/Socket-Programming-in-C-C-.jpg)

## Stages for Server
##### 1. Socket Creation
    int sockfd = socket(domain, type, protocol)

* sockfd: socket descriptor, an integer (like a file-handle)
* domain: integer, communication domain e.g., AF_INET (IPv4 protocol) , AF_INET6 (IPv6 protocol)
* type: communication type
  * SOCK_STREAM: TCP(reliable, connection oriented)
  * SOCK_DGRAM: UDP(unreliable, connectionless)
* protocol: Protocol value for Internet Protocol(IP), which is 0. This is the same number which appears on protocol field in the IP header of a packet.(man protocols for more details)

##### 2. Setsockopt
    int setsockopt(int sockfd, int level, int optname, const void * optval, socklen_t optlen);

* This helps in manipulating options for the socket referred by the file descriptor sockfd. This is completely optional, but it helps in reuse of address and port. Prevents error such as: “address already in use”.

##### 3. Bind
    int bind(int sockfd, const struct sockaddr * addr, socklen_t addrlen);

* After creation of the socket, bind function binds the socket to the address and port number specified in addr(custom data structure). In the example code, we bind the server to the localhost, hence we use INADDR_ANY to specify the IP address.

##### 4. Listen
    int listen(int sockfd, int backlog);

* It puts the server socket in a passive mode, where it waits for the client to approach the server to make a connection. The backlog, defines the maximum length to which the queue of pending connections for sockfd may grow. If a connection request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED.

##### 5. Accept
    int new_socket= accept(int sockfd, struct sockaddr * addr, socklen_t * addrlen);

* It extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected socket, and returns a new file descriptor referring to that socket. At this point, connection is established between client and server, and they are ready to transfer data.

## Stages for Client
##### 1. Socket connection

* Exactly same as that of server’s socket creation

##### 2. Connect
    int connect(int sockfd, const struct sockaddr * addr, socklen_t addrlen);

* The connect() system call connects the socket referred to by the file descriptor sockfd to the address specified by addr. Server’s address and port is specified in addr.

## Basic Client Server using Sockets
The folder named **Q1** contains the codes for the first part of the assignment, i.e., *a basic server and client using sockets*.

The code for the client is in the **client** folder as **client.c**.
The code for the client is in the **server** folder as **server.c**.

The client creates a connection to the server on localhost on some port which is taken input by the user.

To test the code you just need to run the server on a terminal and then run the client on a different terminal (or run the server as a background process and then run the client on the same terminal).

### Instructions:
```
  // run make
  make

  // Run the server first in the server folder
  ./server <port number>
  // Run the client in the client folder
  ./client <localhost ip> <port number as that of server>
  // Then enter name of file you want to download
```
It can handle upto 8 clients. It accepts shell commands like ls and cd. To download a file you need to add **get <file-name>**. To download files from other directories you first need to go to that directory then use **get <file-name>** command.

* You can exit the server by simply using **Ctrl + C** on the server terminal.
* You can close the client by typing "quit" on the client terminal.

1. **server.cpp** is the file that implements the server side:

	* Creates a Socket and binds it to a port(specified as cmd-line argument)
	* Starts listening on the socket.
	* Accepts connections from the client.
	* Receives command from the client.
	* Parses the command and checks for errors & unsupported commands. If Error in request, sends the error to client.
	* All commands are shell commands. They are converted to valid format and executed (by the client/ server as requested).
	* In case of get command, checks for the appropriate file and sends it to the client over a data connection(data port is generated by the server) in blocks.
	* In case of ls command, we use popen("ls","r") and send the list of files over a data connection(data port is generated by the server) in blocks (because the list of files can be huge).
	* In case of cd <directory> command, we use chdir(<directory>) to change the working directory of the server.
	* Closes the connection with client if it receives a "quit" command from the client.
	* Waits for new connections and repeats the above process.

2. **client.cpp** is the file that implements the client side:

	* Creates a Socket and connects to the server via the IP address of the server and port(specified as cmd-line arguments)
	* Parses the command and checks for errors & unsupported commands. If Error in request, prints the error.
	* All commands are shell commands. They are converted to valid format and executed (by the client/ server as requested).
	* In case of get command, receives the file over a data connection(data port is generated by the server) in blocks from the server.
	* In case of ls command, we receive the list of files over a data connection(again, data port is generated by the server) in blocks (because the list of files can be huge).
	* In case of !ls command, we use system("ls") to print the list of files under the client working directory.
	* In case of !cd <directory> command, we use chdir(<directory>) to change the working directory of the client.
	* Returns to Unix prompt at the client if it receives a **quit** command.

## Multiple file transfer using Persistent and Non Persistent Connections
The folder named **Q2** contains the codes for the second part of the assignment, i.e., *Persistent and Non Persistent connections*.

The codes for clients in the **client** folder are **client-persistent.py** and **client-nonpersistent.py** respectively.
The codes for clients in the **server** folder are **server-persistent.py** and **server-nonpersistent.py** respectively.

The client creates a connection to the server on localhost on some port which is taken input by the user.

To test the code you just need to run the server on a terminal and then run the client on a different terminal (or run the server as a background process and then run the client on the same terminal).

The client and server will by default run on port number 9898.

### Instructions:
```
  # In the server folder, run the server file first
  python server-<persistent/nonpersistent>.py
  # In the client folder, in some other terminal, run the client file
  python client<persistent/nonpersistent>.py
  # Then as per the asked inputs, write the inputs
```

*Note: In the second question, the transfer of an empty file will result in an infinite loop.*
*Note: In the second question, if the client requests for a non-existent file, then the server as well as the client processes will terminate.*

### Comparison between Persistent and Non-Persistent Connections

![Comparison graph](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/HTTP_persistent_connection.svg/1280px-HTTP_persistent_connection.svg.png)
